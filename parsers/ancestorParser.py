#from alignments.AncestralState import AncestralState
#from alignments.AncestralStatesList import AncestralStatesList
import os.path
import traceback

class ancestorParser(object):

    """
        Parses ancestral states text files that are generated by the MEGA/MEGA-CC
        software as a part of Maximum Parsimony tree construction
        
        On success, call get_ancestral_states to a list of AncestralState objects
        generated from the ancestral states text file
    """
    def __init__(self):
        self._input_file_name = ''
     #   self._ancestral_states = AncestralStatesList()
        self._messages = []
        
    @property
    def input_file_name(self):
        return self._input_file_name
    
    @input_file_name.setter
    def input_file_name(self, value):    
        self._input_file_name = value
        
    @property
    def messages(self):
        return self._messages
    
    def parse(self):
        try:
            print('parsing ancestor file...')
            result = False
            if os.path.isfile(self._input_file_name) == False:
                IOError('ancestral states file not found')
            input_file = open(self._input_file_name, 'r')
            lines = input_file.readlines()
            input_file.close()
          #  self._set_filename(self._input_file_name)#lines[1])
          #  self._set_newick_string(lines[4])
           # index = 7
            #while index < len(lines):
             #   self._parse_line(lines[index])
              #  index += 1
           # result = (self._ancestral_states.num_nodes > 3) 
            self._parse_line(lines)		   
            if len(lines)>2:#result == True:
                pass#print 'successfully parsed ancestral states file: ' + str(self._ancestral_states.num_nodes) + ' taxa'
            else:
                print('failed to parse ancestral states file')
            return result
        except Exception as e:
            traceback.print_exc()           
            self._messages.append(str(e))
            return False            
    def GetBestNuc(self, Dic):
        TMP={}
        for Node in Dic:
            Nuc2Prob=Dic[Node]
            BestP=0
            BestNuc='?'
            for Nuc in Nuc2Prob:
                P=Nuc2Prob[Nuc]
                if P>BestP:
                    BestNuc=Nuc
                    BestP=P
            TMP[Node]=BestNuc+'\t'+str(BestP)
        return TMP        
            
    def _parse_line(self, Ta):
        Head=Ta[0].strip().split(',')
        Node2Col={}
        Node2Prob={}
        self._Anc_states={}		
        c=0
        Len=len(Head)
        while c<Len:
            i=Head[c].strip()
            #Code=i in Label2Seq
            #if Code==True: 
            if i[:5]=='Node_':			
                Node2Col[i]=c
            self._Anc_states[i]=[]			
            c+=1
        Ta=Ta[1:]
    
        PosiP=1
        for i in Ta:
            i=i.strip().split(',')
            PosiC=int(i[0])
            Nuc=i[1]
            if PosiC!=PosiP:
                PosiP=PosiC
                Node2BestNuc=self.GetBestNuc(Node2Prob)
                for Node in Node2BestNuc:
                    self._Anc_states[Node].append(Node2BestNuc[Node])
                Node2Prob={}
            for Node in Node2Col:
                Prob=i[Node2Col[Node]]
                Code=Node in Node2Prob
                if Code!=True: Node2Prob[Node]={}
                Node2Prob[Node][Nuc]=float(Prob)	
        #self._Anc_states[Node].append(Node2BestNuc[Node])    	

		
        Node2BestNuc=self.GetBestNuc(Node2Prob)
        for Node in Node2BestNuc:
                    self._Anc_states[Node].append(Node2BestNuc[Node])		
        
    def get_ancestor_states(self):
        return self._Anc_states
    